#include "Game.hpp"
#include "TextureManager.hpp"
#include "GameObject.hpp"
#include "Map.hpp"
#include "EntityComponentSystem.hpp"
#include "Components.hpp"


GameObject* player;
GameObject* enemy;
Map* arenaMap;

SDL_Renderer* Game::renderer = nullptr;

Manager manager;
auto& newPlayer( manager.addEntity() );

Game::Game()
{}

Game::~Game()
{}

void Game::init( const char* title, int windowWidth, int windowHeight, bool fullscreen )
{
    int flags = 0;
    if ( fullscreen )
	flags = SDL_WINDOW_FULLSCREEN;



    if ( SDL_Init( SDL_INIT_EVERYTHING ) == 0 )
    {
	printf( "SDL initialized successfully!\n" );
	window = SDL_CreateWindow( title, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, windowWidth, windowHeight, flags );

	if ( window )
	    printf( "Window successfully created!\n" );

	renderer = SDL_CreateRenderer( window, -1, 0 );
	if ( renderer )
	{
	    printf( "Renderer initialized successfully!\n" );
	    SDL_SetRenderDrawColor( renderer, 200, 200, 200, 255 );
	}

	isActive = true;
    }
    else
	isActive = false;


    player = new GameObject( "Assets/BlueMage.png", 0, 0 );
    enemy = new GameObject( "Assets/BlueMage.png", 100, 100 );
    arenaMap = new Map();

    newPlayer.addComponent<PositionComponent>();
    newPlayer.getComponent<PositionComponent>().setPosition( 500, 500 );
}

void Game::handleEvents()
{
    SDL_Event event;
    SDL_PollEvent( &event );

    switch ( event.type)
    {
	case SDL_QUIT:
	    isActive = false;
	    break;

	default:
	    break;
    }
}

void Game::update()
{
    player->update();
    enemy->update();
    manager.update();
    std::cout << newPlayer.getComponent<PositionComponent>().getXPos() << ", " <<
	newPlayer.getComponent<PositionComponent>().getYPos() << "\n";
}

void Game::render()
{
    SDL_RenderClear( renderer );

    arenaMap->drawMap();
    player->render();
    enemy->render();

    SDL_RenderPresent( renderer );
}

void Game::clean()
{
    SDL_DestroyWindow( window );
    SDL_DestroyRenderer( renderer );
    SDL_Quit();

    printf( "SDL cleaned!\n" );
}

bool Game::isRunning() { return this->isActive; }
